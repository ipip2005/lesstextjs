{"version":3,"sources":["truncate.ts"],"names":[],"mappings":"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","file":"truncate.js","sourcesContent":["import { ITruncateOptions } from './ITruncateOptions';\r\nimport { TruncationResult } from './TruncationResult';\r\n\r\nfunction normalizeOptions(options: ITruncateOptions): Required<ITruncateOptions> {\r\n  if (!options.monitorElement) {\r\n    throw new Error('LessText: Monitor element cannot be empty');\r\n  }\r\n\r\n  const originalLineHeight: string = window\r\n    .getComputedStyle(options.monitorElement, undefined)\r\n    .getPropertyValue('line-height');\r\n\r\n  const lineHeight: number = parseInt(originalLineHeight, 10) || 20;\r\n\r\n  return {\r\n    scalableElement: options.monitorElement,\r\n    lineHeight,\r\n    linesCount: 2,\r\n    omission: '...',\r\n    omissionBreakWord: true,\r\n    separator: '',\r\n    ...options\r\n  };\r\n}\r\n\r\nfunction getHeight(element: HTMLElement): number {\r\n  const contentStyles: CSSStyleDeclaration = window.getComputedStyle(element);\r\n  let padding: number = 0;\r\n  if (contentStyles && contentStyles.paddingTop && contentStyles.paddingBottom) {\r\n    padding = parseFloat(contentStyles.paddingTop) + parseFloat(contentStyles.paddingBottom);\r\n  }\r\n\r\n  return element.offsetHeight - padding;\r\n}\r\n\r\nfunction joinTextArray(textArray: string[], separator: string, omission: string): string {\r\n  return textArray.join(separator) + omission;\r\n}\r\n\r\nexport function truncate(rawOptions: ITruncateOptions): Promise<TruncationResult> {\r\n  const options: Required<ITruncateOptions> = normalizeOptions(rawOptions);\r\n\r\n  options.monitorElement.style.lineHeight = `${options.lineHeight}px`;\r\n  options.monitorElement.style.wordWrap = 'break-word';\r\n\r\n  const maxHeight: number = options.lineHeight * options.linesCount;\r\n\r\n  if (getHeight(options.monitorElement) <= maxHeight) { // Had enough space, skip truncating.\r\n    return Promise.resolve(TruncationResult.Skipped);\r\n  }\r\n\r\n  const truncatableText: string = options.scalableElement.textContent || '';\r\n\r\n  if (!truncatableText) { // Spcae is not enough, but there is no text can be truncated.\r\n    return Promise.resolve(TruncationResult.Failed);\r\n  }\r\n\r\n  const textArray: string[] = truncatableText\r\n    .split(options.separator)\r\n    .filter(text => text);\r\n\r\n  const allowedTextNumber: number = textArray.length;\r\n\r\n  let minTextNumber: number = 0, maxTextNumber: number = allowedTextNumber;\r\n\r\n  do {\r\n    const currentTextNumber: number = Math.floor((minTextNumber + maxTextNumber + 1) / 2);\r\n    const currentTruncatedText: string =\r\n      joinTextArray(textArray.slice(0, currentTextNumber - 1), options.separator, options.omission);\r\n    options.scalableElement.textContent = currentTruncatedText;\r\n\r\n    if (getHeight(options.monitorElement) > maxHeight) {\r\n      maxTextNumber = currentTextNumber - 1;\r\n    } else {\r\n      minTextNumber = currentTextNumber;\r\n    }\r\n  } while (minTextNumber < maxTextNumber);\r\n\r\n  if (minTextNumber === 0) { // We truncated everyting.\r\n    return Promise.resolve(TruncationResult.Failed);\r\n  } else {\r\n    return Promise.resolve(TruncationResult.Success);\r\n  }\r\n}\r\n"],"sourceRoot":"../src"}