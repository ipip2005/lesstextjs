{"version":3,"sources":["truncate.ts"],"names":[],"mappings":"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","file":"truncate.js","sourcesContent":["import { ITruncateOptions } from './ITruncateOptions';\r\nimport { TruncationResult } from './TruncationResult';\r\n\r\n/**\r\n * Normailize - Set default value of options to make all fields required.\r\n * @param options - The truncate options object that has optional fields.\r\n */\r\nfunction normalizeOptions(options: ITruncateOptions): Required<ITruncateOptions> {\r\n  if (!options.monitorElement) {\r\n    throw new Error('LessText: Monitor element cannot be empty');\r\n  }\r\n\r\n  const originalLineHeight: string = window\r\n    .getComputedStyle(options.monitorElement, undefined)\r\n    .getPropertyValue('line-height');\r\n\r\n  const lineHeight: number = parseInt(originalLineHeight, 10) || 20;\r\n\r\n  return {\r\n    flexibleElement: options.monitorElement,\r\n    lineHeight,\r\n    linesCount: 2,\r\n    omission: '...',\r\n    omissionBreakLastWord: false,\r\n    reserveExtraSpace: false,\r\n    separator: '',\r\n    ...options\r\n  };\r\n}\r\n\r\nfunction getHeight(element: HTMLElement): number {\r\n  const contentStyles: CSSStyleDeclaration = window.getComputedStyle(element);\r\n  let padding: number = 0;\r\n  if (contentStyles && contentStyles.paddingTop && contentStyles.paddingBottom) {\r\n    padding = parseFloat(contentStyles.paddingTop) + parseFloat(contentStyles.paddingBottom);\r\n  }\r\n\r\n  return element.offsetHeight - padding;\r\n}\r\n\r\nfunction hasEnoughSpace(options: Required<ITruncateOptions>): boolean {\r\n  const maxHeight: number = options.lineHeight * options.linesCount;\r\n\r\n  return getHeight(options.monitorElement) <= maxHeight;\r\n}\r\n\r\nexport function truncate(rawOptions: ITruncateOptions): Promise<TruncationResult> {\r\n  const options: Required<ITruncateOptions> = normalizeOptions(rawOptions);\r\n\r\n  options.monitorElement.style.lineHeight = `${options.lineHeight}px`;\r\n  options.monitorElement.style.wordWrap = 'break-word';\r\n\r\n  // --------------------------\r\n  // FAST RETURN: Skipped\r\n  // Had enough space, skip truncating.\r\n  // --------------------------\r\n  if (hasEnoughSpace(options)) {\r\n    return Promise.resolve(TruncationResult.Skipped);\r\n  }\r\n\r\n  // This is the text where we can operate.\r\n  const scalableText: string = options.flexibleElement.textContent || '';\r\n\r\n  // --------------------------\r\n  // FAST RETURN: Failed\r\n  // We cannot do anything if there is no text that can be truncated.\r\n  // --------------------------\r\n  if (!scalableText) {\r\n    return Promise.resolve(TruncationResult.Failed);\r\n  }\r\n\r\n  const wordsArray: string[] = scalableText\r\n    .split(options.separator)\r\n    .filter(text => options.reserveExtraSpace || text);\r\n\r\n  const allowedWordsCount: number = wordsArray.length;\r\n\r\n  let minWordsCount: number = 0, maxWordsCount: number = allowedWordsCount;\r\n\r\n  // Do a binary search to fit as many words as we can.\r\n  do {\r\n    const experimentWordsCount: number = Math.floor((minWordsCount + maxWordsCount + 1) / 2);\r\n    const experimentText: string =\r\n      wordsArray.slice(0, experimentWordsCount - 1).join(options.separator) + options.omission;\r\n    options.flexibleElement.textContent = experimentText;\r\n\r\n    if (hasEnoughSpace(options)) {\r\n      minWordsCount = experimentWordsCount;\r\n    } else {\r\n      maxWordsCount = experimentWordsCount - 1;\r\n    }\r\n  } while (minWordsCount < maxWordsCount);\r\n\r\n  // --------------------------\r\n  // FAST RETURN: Failed\r\n  // We don't have space for even one word, and it is not allowed to break the last word.\r\n  // --------------------------\r\n  if (minWordsCount === 0 && !options.omissionBreakLastWord) {\r\n    return Promise.resolve(TruncationResult.Failed);\r\n  }\r\n\r\n  // --------------------------\r\n  // FAST RETURN: Unexpected\r\n  // The hit of this code means no text is truncated,\r\n  // in which case the function should already be returned at the early stage.\r\n  // --------------------------\r\n  if (minWordsCount === allowedWordsCount) {\r\n    return Promise.resolve(TruncationResult.Unexpected);\r\n  }\r\n\r\n  // --------------------------\r\n  // FAST RETURN: Success\r\n  // The words have been truncated and it is not configured to further truncate the last word.\r\n  // --------------------------\r\n  if (!options.omissionBreakLastWord) {\r\n    return Promise.resolve(TruncationResult.Success);\r\n  }\r\n\r\n  // We will try to show as many characters as we can from the last word that was truncated away.\r\n  const lastWord: string = wordsArray[minWordsCount + 1];\r\n\r\n  let currentText: string = wordsArray.slice(0, minWordsCount).join(options.separator);\r\n  let nextText: string = currentText + options.separator;\r\n  let experimentCharacterIndex: number = 0;\r\n  options.flexibleElement.textContent = nextText + options.omission;\r\n\r\n  while (hasEnoughSpace(options) && experimentCharacterIndex < lastWord.length) {\r\n    currentText = nextText;\r\n    nextText = currentText + lastWord[experimentCharacterIndex++];\r\n    options.flexibleElement.textContent = nextText + options.omission;\r\n  }\r\n\r\n  options.flexibleElement.textContent = currentText + options.omission;\r\n\r\n  // --------------------------\r\n  // FAST RETURN: Success\r\n  // We are able to show as many characters as we can.\r\n  // --------------------------\r\n  return Promise.resolve(TruncationResult.Success);\r\n}\r\n"],"sourceRoot":"../src"}